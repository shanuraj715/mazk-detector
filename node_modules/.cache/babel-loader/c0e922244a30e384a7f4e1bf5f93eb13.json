{"ast":null,"code":"/**\n * @fileoverview Strengthen the ability of file system\n * @author wliao <wliao@Ctrip.com> \n */\nvar fs = require('fs');\n\nvar util = require('utils-extend');\n\nvar path = require('path');\n\nvar fileMatch = require('file-match');\n\nfunction checkCbAndOpts(options, callback) {\n  if (util.isFunction(options)) {\n    return {\n      options: null,\n      callback: options\n    };\n  } else if (util.isObject(options)) {\n    return {\n      options: options,\n      callback: callback\n    };\n  } else {\n    return {\n      options: null,\n      callback: util.noop\n    };\n  }\n}\n\nfunction getExists(filepath) {\n  var exists = fs.existsSync(filepath);\n\n  if (exists) {\n    return filepath;\n  } else {\n    return getExists(path.dirname(filepath));\n  }\n}\n\nutil.extend(exports, fs);\n/**\n * @description\n * Assign node origin methods to fs\n */\n\nexports.fs = fs;\nexports.fileMatch = fileMatch;\n/**\n * @description\n * Create dir, if dir exist, it will only invoke callback.\n *\n * @example\n * ```js\n *   fs.mkdir('1/2/3/4/5', 511);\n *   fs.mkdir('path/2/3', function() {});\n * ```\n */\n\nexports.mkdir = function (filepath, mode, callback) {\n  var root = getExists(filepath);\n  var children = path.relative(root, filepath);\n\n  if (util.isFunction(mode)) {\n    callback = mode;\n    mode = null;\n  }\n\n  if (!util.isFunction(callback)) {\n    callback = util.noop;\n  }\n\n  mode = mode || 511;\n  if (!children) return callback();\n  children = children.split(path.sep);\n\n  function create(filepath) {\n    if (create.count === children.length) {\n      return callback();\n    }\n\n    filepath = path.join(filepath, children[create.count]);\n    fs.mkdir(filepath, mode, function (err) {\n      create.count++;\n      create(filepath);\n    });\n  }\n\n  create.count = 0;\n  create(root);\n};\n/**\n * @description\n * Same as mkdir, but it is synchronous\n */\n\n\nexports.mkdirSync = function (filepath, mode) {\n  var root = getExists(filepath);\n  var children = path.relative(root, filepath);\n  if (!children) return;\n  children = children.split(path.sep);\n  children.forEach(function (item) {\n    root = path.join(root, item);\n    fs.mkdirSync(root, mode);\n  });\n};\n/**\n * @description \n * Create file, if path don't exists, it will not throw error.\n * And will mkdir for path, it is asynchronous\n * \n * @example\n * ```js\n *   fs.writeFile('path/filename.txt', 'something')\n *   fs.writeFile('path/filename.txt', 'something', {})\n * ```\n */\n\n\nexports.writeFile = function (filename, data, options, callback) {\n  var result = checkCbAndOpts(options, callback);\n  var dirname = path.dirname(filename);\n  options = result.options;\n  callback = result.callback; // Create dir first\n\n  exports.mkdir(dirname, function () {\n    fs.writeFile(filename, data, options, callback);\n  });\n};\n/**\n * @description\n * Same as writeFile, but it is synchronous\n */\n\n\nexports.writeFileSync = function (filename, data, options) {\n  var dirname = path.dirname(filename);\n  exports.mkdirSync(dirname);\n  fs.writeFileSync(filename, data, options);\n};\n/**\n * @description\n * Asynchronously copy a file\n * @example\n * file.copyFile('demo.txt', 'demo.dest.txt', { done: function(err) { }})\n */\n\n\nexports.copyFile = function (srcpath, destpath, options) {\n  options = util.extend({\n    encoding: 'utf8',\n    done: util.noop\n  }, options || {});\n\n  if (!options.process) {\n    options.encoding = null;\n  }\n\n  fs.readFile(srcpath, {\n    encoding: options.encoding\n  }, function (err, contents) {\n    if (err) return options.done(err);\n\n    if (options.process) {\n      contents = options.process(contents);\n    }\n\n    exports.writeFile(destpath, contents, options, options.done);\n  });\n};\n/**\n * @description\n * Copy file to dest, if no process options, it will only copy file to dest\n * @example\n * file.copyFileSync('demo.txt', 'demo.dest.txt' { process: function(contents) { }});\n * file.copyFileSync('demo.png', 'dest.png');\n */\n\n\nexports.copyFileSync = function (srcpath, destpath, options) {\n  options = util.extend({\n    encoding: 'utf8'\n  }, options || {});\n  var contents;\n\n  if (options.process) {\n    contents = fs.readFileSync(srcpath, options);\n    contents = options.process(contents, srcpath, options.relative);\n\n    if (util.isObject(contents) && contents.filepath) {\n      destpath = contents.filepath;\n      contents = contents.contents;\n    }\n\n    exports.writeFileSync(destpath, contents, options);\n  } else {\n    contents = fs.readFileSync(srcpath);\n    exports.writeFileSync(destpath, contents);\n  }\n};\n/**\n * @description\n * Recurse into a directory, executing callback for each file and folder\n * if the filename is undefiend, the callback is for folder, otherwise for file.\n * and it is asynchronous\n * @example\n * file.recurse('path', function(filepath, filename) { });\n * file.recurse('path', ['*.js', 'path/**\\/*.html'], function(filepath, relative, filename) { });\n */\n\n\nexports.recurse = function (dirpath, filter, callback) {\n  if (util.isFunction(filter)) {\n    callback = filter;\n    filter = null;\n  }\n\n  var filterCb = fileMatch(filter);\n  var rootpath = dirpath;\n\n  function recurse(dirpath) {\n    fs.readdir(dirpath, function (err, files) {\n      if (err) return callback(err);\n      files.forEach(function (filename) {\n        var filepath = path.join(dirpath, filename);\n        fs.stat(filepath, function (err, stats) {\n          var relative = path.relative(rootpath, filepath);\n          var flag = filterCb(relative);\n\n          if (stats.isDirectory()) {\n            recurse(filepath);\n            if (flag) callback(filepath, relative);\n          } else {\n            if (flag) callback(filepath, relative, filename);\n          }\n        });\n      });\n    });\n  }\n\n  recurse(dirpath);\n};\n/**\n * @description\n * Same as recurse, but it is synchronous\n * @example\n * file.recurseSync('path', function(filepath, filename) {});\n * file.recurseSync('path', ['*.js', 'path/**\\/*.html'], function(filepath, relative, filename) {});\n */\n\n\nexports.recurseSync = function (dirpath, filter, callback) {\n  if (util.isFunction(filter)) {\n    callback = filter;\n    filter = null;\n  }\n\n  var filterCb = fileMatch(filter);\n  var rootpath = dirpath;\n\n  function recurse(dirpath) {\n    fs.readdirSync(dirpath).forEach(function (filename) {\n      var filepath = path.join(dirpath, filename);\n      var stats = fs.statSync(filepath);\n      var relative = path.relative(rootpath, filepath);\n      var flag = filterCb(relative);\n\n      if (stats.isDirectory()) {\n        recurse(filepath);\n        if (flag) callback(filepath, relative);\n      } else {\n        if (flag) callback(filepath, relative, filename);\n      }\n    });\n  }\n\n  recurse(dirpath);\n};\n/**\n * @description\n * Remove folder and files in folder, but it's synchronous\n * @example\n * file.rmdirSync('path');\n */\n\n\nexports.rmdirSync = function (dirpath) {\n  exports.recurseSync(dirpath, function (filepath, relative, filename) {\n    // it is file, otherwise it's folder\n    if (filename) {\n      fs.unlinkSync(filepath);\n    } else {\n      fs.rmdirSync(filepath);\n    }\n  });\n  fs.rmdirSync(dirpath);\n};\n/**\n * @description\n * Copy dirpath to destpath, pass process callback for each file hanlder\n * if you want to change the dest filepath, process callback return { contents: '', filepath: ''}\n * otherwise only change contents\n * @example\n * file.copySync('path', 'dest');\n * file.copySync('src', 'dest/src');\n * file.copySync('path', 'dest', { process: function(contents, filepath) {} });\n * file.copySync('path', 'dest', { process: function(contents, filepath) {} }, noProcess: ['']);\n */\n\n\nexports.copySync = function (dirpath, destpath, options) {\n  options = util.extend({\n    encoding: 'utf8',\n    filter: null,\n    noProcess: ''\n  }, options || {});\n  var noProcessCb = fileMatch(options.noProcess); // Make sure dest root\n\n  exports.mkdirSync(destpath);\n  exports.recurseSync(dirpath, options.filter, function (filepath, relative, filename) {\n    if (!filename) return;\n    var newpath = path.join(destpath, relative);\n    var opts = {\n      relative: relative\n    };\n\n    if (options.process && !noProcessCb(relative)) {\n      opts.encoding = options.encoding;\n      opts.process = options.process;\n    }\n\n    exports.copyFileSync(filepath, newpath, opts);\n  });\n};","map":{"version":3,"sources":["D:/Projects/maskdetector/node_modules/file-system/file-system.js"],"names":["fs","require","util","path","fileMatch","checkCbAndOpts","options","callback","isFunction","isObject","noop","getExists","filepath","exists","existsSync","dirname","extend","exports","mkdir","mode","root","children","relative","split","sep","create","count","length","join","err","mkdirSync","forEach","item","writeFile","filename","data","result","writeFileSync","copyFile","srcpath","destpath","encoding","done","process","readFile","contents","copyFileSync","readFileSync","recurse","dirpath","filter","filterCb","rootpath","readdir","files","stat","stats","flag","isDirectory","recurseSync","readdirSync","statSync","rmdirSync","unlinkSync","copySync","noProcess","noProcessCb","newpath","opts"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Strengthen the ability of file system\n * @author wliao <wliao@Ctrip.com> \n */\nvar fs = require('fs');\nvar util = require('utils-extend');\nvar path = require('path');\nvar fileMatch = require('file-match');\n\nfunction checkCbAndOpts(options, callback) {\n  if (util.isFunction(options)) {\n    return {\n      options: null,\n      callback: options\n    };\n  } else if (util.isObject(options)) {\n    return {\n      options: options,\n      callback: callback\n    };\n  } else {\n    return {\n      options: null,\n      callback: util.noop\n    };\n  }\n}\n\nfunction getExists(filepath) {\n  var exists = fs.existsSync(filepath);\n\n  if (exists) {\n    return filepath;\n  } else {\n    return getExists(path.dirname(filepath));\n  }\n}\n\nutil.extend(exports, fs);\n\n/**\n * @description\n * Assign node origin methods to fs\n */\nexports.fs = fs;\n\nexports.fileMatch = fileMatch;\n\n/**\n * @description\n * Create dir, if dir exist, it will only invoke callback.\n *\n * @example\n * ```js\n *   fs.mkdir('1/2/3/4/5', 511);\n *   fs.mkdir('path/2/3', function() {});\n * ```\n */\nexports.mkdir = function(filepath, mode, callback) {\n  var root = getExists(filepath);\n  var children  = path.relative(root, filepath);\n\n  if (util.isFunction(mode)) {\n    callback = mode;\n    mode = null;\n  }\n\n  if (!util.isFunction(callback)) {\n    callback = util.noop;\n  }\n\n  mode = mode || 511;\n\n  if (!children) return callback();\n\n  children = children.split(path.sep);\n\n  function create(filepath) {\n    if (create.count === children.length) {\n      return callback();\n    }\n\n    filepath = path.join(filepath, children[create.count]);\n\n    fs.mkdir(filepath, mode, function(err) {\n      create.count++;\n      create(filepath);\n    });\n  }\n\n  create.count = 0;\n  create(root);\n};\n\n/**\n * @description\n * Same as mkdir, but it is synchronous\n */\nexports.mkdirSync = function(filepath, mode) {\n  var root = getExists(filepath);\n  var children  = path.relative(root, filepath);\n\n  if (!children) return;\n\n  children = children.split(path.sep);\n\n  children.forEach(function(item) {\n    root = path.join(root, item);\n    fs.mkdirSync(root, mode);\n  });\n};\n\n/**\n * @description \n * Create file, if path don't exists, it will not throw error.\n * And will mkdir for path, it is asynchronous\n * \n * @example\n * ```js\n *   fs.writeFile('path/filename.txt', 'something')\n *   fs.writeFile('path/filename.txt', 'something', {})\n * ```\n */\nexports.writeFile = function(filename, data, options, callback) {\n  var result = checkCbAndOpts(options, callback);\n  var dirname = path.dirname(filename);\n  options = result.options;\n  callback = result.callback;\n\n  // Create dir first\n  exports.mkdir(dirname, function() {\n    fs.writeFile(filename, data, options, callback);\n  });\n};\n\n/**\n * @description\n * Same as writeFile, but it is synchronous\n */\nexports.writeFileSync = function(filename, data, options) {\n  var dirname = path.dirname(filename);\n\n  exports.mkdirSync(dirname);\n  fs.writeFileSync(filename, data, options);\n};\n\n/**\n * @description\n * Asynchronously copy a file\n * @example\n * file.copyFile('demo.txt', 'demo.dest.txt', { done: function(err) { }})\n */\nexports.copyFile = function(srcpath, destpath, options) {\n  options = util.extend({\n    encoding: 'utf8',\n    done: util.noop\n  }, options || {});\n\n  if (!options.process) {\n    options.encoding = null;\n  }\n\n  fs.readFile(srcpath, {\n    encoding: options.encoding\n  }, function(err, contents) {\n    if (err) return options.done(err);\n\n    if (options.process) {\n      contents = options.process(contents);\n    }\n\n    exports.writeFile(destpath, contents, options, options.done);\n  });\n};\n\n/**\n * @description\n * Copy file to dest, if no process options, it will only copy file to dest\n * @example\n * file.copyFileSync('demo.txt', 'demo.dest.txt' { process: function(contents) { }});\n * file.copyFileSync('demo.png', 'dest.png');\n */\nexports.copyFileSync = function(srcpath, destpath, options) {\n  options = util.extend({\n    encoding: 'utf8' \n  }, options || {});\n  var contents;\n\n  if (options.process) {\n    contents = fs.readFileSync(srcpath, options);\n    contents = options.process(contents, srcpath, options.relative);\n\n    if (util.isObject(contents) && contents.filepath) {\n      destpath = contents.filepath;\n      contents = contents.contents;\n    }\n\n    exports.writeFileSync(destpath, contents, options);    \n  } else {\n    contents = fs.readFileSync(srcpath);\n    exports.writeFileSync(destpath, contents);\n  }\n};\n\n/**\n * @description\n * Recurse into a directory, executing callback for each file and folder\n * if the filename is undefiend, the callback is for folder, otherwise for file.\n * and it is asynchronous\n * @example\n * file.recurse('path', function(filepath, filename) { });\n * file.recurse('path', ['*.js', 'path/**\\/*.html'], function(filepath, relative, filename) { });\n */\nexports.recurse = function(dirpath, filter, callback) {\n  if (util.isFunction(filter)) {\n    callback = filter;\n    filter = null;\n  }\n  var filterCb = fileMatch(filter);\n  var rootpath = dirpath;\n\n  function recurse(dirpath) {\n    fs.readdir(dirpath, function(err, files) {\n      if (err) return callback(err);\n\n      files.forEach(function(filename) {\n        var filepath = path.join(dirpath, filename);\n\n        fs.stat(filepath, function(err, stats) {\n            var relative = path.relative(rootpath, filepath);\n            var flag = filterCb(relative);\n\n            if (stats.isDirectory()) {\n              recurse(filepath);\n              if (flag) callback(filepath, relative);\n            } else {\n              if (flag) callback(filepath, relative, filename);\n            }\n          });\n        });\n    });\n  }\n\n  recurse(dirpath);\n};\n\n/**\n * @description\n * Same as recurse, but it is synchronous\n * @example\n * file.recurseSync('path', function(filepath, filename) {});\n * file.recurseSync('path', ['*.js', 'path/**\\/*.html'], function(filepath, relative, filename) {});\n */\nexports.recurseSync = function(dirpath, filter, callback) {\n  if (util.isFunction(filter)) {\n    callback = filter;\n    filter = null;\n  }\n  var filterCb = fileMatch(filter);\n  var rootpath = dirpath;\n\n  function recurse(dirpath) {\n    fs.readdirSync(dirpath).forEach(function(filename) {\n      var filepath = path.join(dirpath, filename);\n      var stats = fs.statSync(filepath);\n      var relative = path.relative(rootpath, filepath);\n      var flag = filterCb(relative);\n\n      if (stats.isDirectory()) {\n        recurse(filepath);\n        if (flag) callback(filepath, relative);\n      } else {\n        if (flag) callback(filepath, relative, filename);\n      }\n    });\n  }\n\n  recurse(dirpath);\n};\n\n/**\n * @description\n * Remove folder and files in folder, but it's synchronous\n * @example\n * file.rmdirSync('path');\n */\nexports.rmdirSync = function(dirpath) {\n  exports.recurseSync(dirpath, function(filepath, relative, filename) {\n    // it is file, otherwise it's folder\n    if (filename) {\n      fs.unlinkSync(filepath);\n    } else {\n      fs.rmdirSync(filepath);\n    }\n  });\n\n  fs.rmdirSync(dirpath);\n};\n\n/**\n * @description\n * Copy dirpath to destpath, pass process callback for each file hanlder\n * if you want to change the dest filepath, process callback return { contents: '', filepath: ''}\n * otherwise only change contents\n * @example\n * file.copySync('path', 'dest');\n * file.copySync('src', 'dest/src');\n * file.copySync('path', 'dest', { process: function(contents, filepath) {} });\n * file.copySync('path', 'dest', { process: function(contents, filepath) {} }, noProcess: ['']);\n */\nexports.copySync = function(dirpath, destpath, options) {\n  options = util.extend({\n    encoding: 'utf8',\n    filter: null,\n    noProcess: ''\n  }, options || {});\n  var noProcessCb = fileMatch(options.noProcess);\n\n  // Make sure dest root\n  exports.mkdirSync(destpath);\n  exports.recurseSync(dirpath, options.filter, function(filepath, relative, filename) {\n    if (!filename) return;\n    var newpath = path.join(destpath, relative);\n    var opts = {\n      relative: relative\n    };\n\n    if (options.process && !noProcessCb(relative)) {\n      opts.encoding = options.encoding;\n      opts.process = options.process;\n    }\n\n    exports.copyFileSync(filepath, newpath, opts);\n  });\n};"]},"metadata":{},"sourceType":"script"}